package com.eebbk.internal.question.convertor.util;

import java.io.File;
import java.io.InputStream;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

import org.apache.commons.collections.CollectionUtils;

import com.eebbk.edu.common.cloudfile.QiniuUtil;
import com.eebbk.edu.common.util.StrUtils;
import com.eebbk.internal.question.convertor.constant.CommonConstant;
import com.eebbk.internal.question.convertor.dao.mapper.QuestionMapper2;
import com.eebbk.internal.question.convertor.pojo.QuestionXuekubaoPojo;
import com.eebbk.internal.question.convertor.util.AssignListUtils;
import com.eebbk.internal.question.convertor.util.DataFormatUtil;
import com.eebbk.internal.question.convertor.util.FtpUtil;
import com.eebbk.internal.question.convertor.util.HtmlTools;
import com.eebbk.internal.question.convertor.util.HtmlUtil;
import com.eebbk.internal.question.convertor.vo.QuestionsVo;
import com.eebbk.internal.question.convertor.vo.SubQuestionVo;

public class XuekubaoDataHandlerUtil {
	public static void insertQuestionXuekubao(List<QuestionsVo> questionList,QuestionMapper2 questionMapper,Integer tableFlag,Integer handerWay) {
		System.out.println(questionList.size());
		long start,end;
		start = System.currentTimeMillis();
		System.out.println("数据开始处理时间："+start);
		Iterator<QuestionsVo> iteratorQuestionList = questionList.iterator();
		QuestionXuekubaoPojo questionXuekubao=null;
		int count=0;
		List<QuestionXuekubaoPojo> questionXuekubaoList=new ArrayList<QuestionXuekubaoPojo>();
		while (iteratorQuestionList.hasNext()) {
			questionXuekubao=new QuestionXuekubaoPojo();
			QuestionsVo questionsVo = iteratorQuestionList.next();
			Integer paperFlag = questionsVo.getPaperFlag();
			Integer idOldTest = questionsVo.getId();
			System.out.println("开始处理第"+(++count)+"条数据");
			String content="";
			String answer="";
			StringBuffer answerSub=new StringBuffer("");
			StringBuffer parseSub=new StringBuffer("");
			String solution="";
			String course=null;
			String grade=null;
			String  qiniuTitleFlag=null;
			String  qiniuContentFlag=null;
			String  qiniuAnswer1Flag=null;
			String  qiniuAnswer2Flag=null;
			String  qiniuSubAnswerFlag=null;
			String  qiniuParseFlag=null;
			String  qiniuSubParseFlag=null;
			String answer1Sub=null;
			String answer2Sub=null;
			Integer contentExistFlag=1;
			Integer answerExistFlag=1;
			Integer parseExistFlag=1;
			String picExistFlagSubAnswer=null;
			String  picExistflagSubParse=null;
			StringBuffer titleBuffer = new StringBuffer("<div class=\"question_title\">");
			Integer id = questionsVo.getId();
			String title = questionsVo.getTitle();
			if (StrUtils.isNotEmpty(title)) {
				title=DataFormatUtil.formatUploadData(title);
			}else{
				contentExistFlag=0;
			}
			titleBuffer=titleBuffer.append(title).append("</div>");
			String answer1 = questionsVo.getAnswer1();
			String answer2 = questionsVo.getAnswer2();
			if (StrUtils.isNotEmpty(answer1)&&StrUtils.isNotEmpty(answer2)) {
				answerExistFlag=1;
			}
			if (StrUtils.isEmpty(answer1)&&StrUtils.isEmpty(answer2)) {
				answerExistFlag=0;
			}
			if (StrUtils.isNotEmpty(answer1)) {
				StringBuffer as = new StringBuffer("");
				answer1=DataFormatUtil.formatUploadData(answer1);
				String[] split = answer1.split("\\$###\\$");
				for (int i = 0; i < split.length; i++) {
					if (StrUtils.isNotEmpty(split[i])) {
						if (split.length>1) {
							as=as.append("&nbsp;&nbsp;"+split[i]+"&nbsp;&nbsp;");
						}else{
							as=as.append(split[i]);
						}
					}
				}
				answer1=as.toString();
			}
			String  picExistflagAnswer1=null;
			if (tableFlag==0) {
				Map<String,Object> mapAnswer1=getNewImgsrc(answer1);
				Object errorAnswer1 = mapAnswer1.get("error");
				if (errorAnswer1!=null) {
					qiniuAnswer1Flag="0";
				}
				answer1=(String) mapAnswer1.get("msg");
				picExistflagAnswer1 = (String) mapAnswer1.get("picExistflag");
			}else if (tableFlag==1) {
			}
			
			
			if (StrUtils.isNotEmpty(answer2)) {
				answer2=DataFormatUtil.formatUploadData(answer2);
			}
			String  picExistflagAnswer2=null;
			if (tableFlag==0) {
				Map<String,Object> mapAnswer2=getNewImgsrc(answer2);
				Object errorAnswer2 = mapAnswer2.get("error");
				if (errorAnswer2!=null) {
					qiniuAnswer2Flag="0";
				}
				answer2=(String) mapAnswer2.get("msg");
				picExistflagAnswer2 = (String) mapAnswer2.get("picExistflag");
			}else if (tableFlag==1) {
			}
			
			
			String parse = questionsVo.getParse();
			if (StrUtils.isNotEmpty(parse)) {
				parse=DataFormatUtil.formatUploadData(parse);
			}else{
				parseExistFlag=0;
			}
			String  picExistflagParse=null;
			if (tableFlag==0) {
				Map<String,Object> mapParse=getNewImgsrc(parse);
				Object errorParse = mapParse.get("error");
				if (errorParse!=null) {
					qiniuParseFlag="0";
				}
				parse=(String) mapParse.get("msg");
				picExistflagParse = (String) mapParse.get("picExistflag");
			}else if (tableFlag==1) {
			}
			
			String gradeName = questionsVo.getGradeName();
			String subjectName = questionsVo.getSubjectName();
			List<SubQuestionVo> subQuestionList=null;
			if (questionsVo!=null&&id!=null) {
				Integer isSub = questionsVo.getIsSub();
				if (isSub!=null&&1==isSub) {
					subQuestionList = questionMapper.selectSubQuestionByQueId(id);
				}
			}
			//如果存在子题，则区子题的题干与 母体的题干进行拼接
			StringBuffer subTitles=new StringBuffer("");
			StringBuffer subTitleOne=null;
	        SimpleDateFormat sdf = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss"); 
	        Integer testid= questionsVo.getId();
	        
			if (CollectionUtils.isNotEmpty(subQuestionList)) {
				String  picExistflagSubAnswer1="picExistFlag:1";
				String  picExistflagSubAnswer2="picExistFlag:1";
				String qiniuSubAnswer1Flag="1";
				String qiniuSubAnswer2Flag="1";
				//判断是否有答案解析是否存在
				for (SubQuestionVo nextSubQue:subQuestionList){
					String answerSub1 = nextSubQue.getAnswer1();
					String answerSub2 = nextSubQue.getAnswer2();
					String parseSub0 = nextSubQue.getParse();
					if (1==answerExistFlag) {
					}else{
						if (StrUtils.isEmpty(answerSub1)&&StrUtils.isEmpty(answerSub2)) {
							answerExistFlag=0;
						}else{
							answerExistFlag=1;
						}
					}
					if (StrUtils.isNotEmpty(answerSub1)) {
						Map<String,Object> mapSubAnswer1=getNewImgsrc(answerSub1);
						Object errorSubAnswer1 = mapSubAnswer1.get("error");
						if (errorSubAnswer1!=null) {
							qiniuSubAnswer1Flag="0";
						}
						answerSub1=(String) mapSubAnswer1.get("msg");
						answerSub=answerSub.append(getAnwerText(answerSub1,null)).append("<br/>");

						picExistflagSubAnswer1 = (String) mapSubAnswer1.get("picExistflag");
					}
					if (StrUtils.isNotEmpty(answerSub2)) {
						Map<String,Object> mapSubAnswer2=getNewImgsrc(answerSub2);
						Object errorSubAnswer2 = mapSubAnswer2.get("error");
						if (errorSubAnswer2!=null) {
							qiniuSubAnswer2Flag="0";
						}
						answerSub2=(String) mapSubAnswer2.get("msg");
						answerSub=answerSub.append(getAnwerText(null,answerSub2)).append("<br/>");

						picExistflagSubAnswer2 = (String) mapSubAnswer2.get("picExistflag");
					}
					
					if (picExistflagSubAnswer1!=null&&picExistflagSubAnswer2!=null) {
						if (!"picExistFlag:1".equals(picExistflagSubAnswer1)&&!"picExistFlag:1".equals(picExistflagSubAnswer2)) {
							picExistFlagSubAnswer="picExistFlag:0";
						}
					}
					if (!"1".equals(qiniuSubAnswer1Flag)&&!"1".equals(qiniuSubAnswer2Flag)) {
						qiniuSubAnswerFlag="0";
					}
					
					if (1==parseExistFlag) {
					}else{
						if (StrUtils.isEmpty(parseSub0)) {
							parseExistFlag=0;
						}else{
							parseExistFlag=1;
							Map<String,Object> mapSubParse=getNewImgsrc(parseSub0);
							Object errorSubParse = mapSubParse.get("error");
							if (errorSubParse!=null) {
								qiniuSubParseFlag="0";
							}
							parseSub0=(String) mapSubParse.get("msg");
							parseSub=parseSub.append(parseSub0).append("<br/>");
							String picExistflagSubParseC = (String) mapSubParse.get("picExistflag");
							if ("picExistFlag:0".equals(picExistflagSubParseC)) {
								picExistflagSubParse=picExistflagSubParseC;
							}
						}
					}
				}
				Boolean flag=false;//是否为选择性的题
				Iterator<SubQuestionVo> iteratorSubQuestion = subQuestionList.iterator();
				//该循环判断是否是带选项的题
				
				for (SubQuestionVo nextSubQue:subQuestionList){
//					SubQuestionVo nextSubQue = iteratorSubQuestion.next();
					String optionA = nextSubQue.getOptionA();
					String optionB = nextSubQue.getOptionB();
					String optionC = nextSubQue.getOptionC();
					String optionD = nextSubQue.getOptionD();
					if (StrUtils.isNotEmpty(optionA)||StrUtils.isNotEmpty(optionB)||StrUtils.isNotEmpty(optionC)||StrUtils.isNotEmpty(optionD)) {
						flag=true;
					}
				}
				while (iteratorSubQuestion.hasNext()) {
					subTitleOne = new StringBuffer("<p class=\"question_option\">");
					SubQuestionVo nextSubQue = iteratorSubQuestion.next();
					String subTitle = nextSubQue.getTitle();
					if (StrUtils.isEmpty(subTitle)) {
						contentExistFlag=0;
					}
					String optionA = nextSubQue.getOptionA();
					String optionB = nextSubQue.getOptionB();
					String optionC = nextSubQue.getOptionC();
					String optionD = nextSubQue.getOptionD();
					
					if (StrUtils.isEmpty(optionA)&&StrUtils.isNotEmpty(optionB)) {
						contentExistFlag=0;
					}
					if (StrUtils.isNotEmpty(optionC)) {
						if (StrUtils.isEmpty(optionA)||StrUtils.isEmpty(optionB)) {
							contentExistFlag=0;
						}
					}
					if (StrUtils.isNotEmpty(optionD)) {
						if (StrUtils.isEmpty(optionA)||StrUtils.isEmpty(optionB)||StrUtils.isEmpty(optionC)) {
							contentExistFlag=0;
						}
					}
					subTitleOne=subTitleOne.append(subTitle).append("&nbsp;");
					if (flag) {
						if (StrUtils.isNotEmpty(optionA)) {
							subTitleOne=subTitleOne.append("A.").append(optionA).append("&nbsp;&nbsp;");
						}
						if (StrUtils.isNotEmpty(optionB)) {
							subTitleOne=subTitleOne.append("B.").append(optionB).append("&nbsp;&nbsp;");
						}
						if (StrUtils.isNotEmpty(optionC)) {
							subTitleOne=subTitleOne.append("C.").append(optionC).append("&nbsp;&nbsp;");
						}
						if (StrUtils.isNotEmpty(optionD)) {
							subTitleOne=subTitleOne.append("D.").append(optionD).append("&nbsp;&nbsp;");
						}
					}
					subTitleOne = subTitleOne.append("</p>");
					subTitles.append(subTitleOne);
				}
			}else{
				//isNormal：当试题为选择题并进行了题干与选项分离，则该字段为1，否则为0
				Integer a=1;
				if (a==questionsVo.getIsNormal()) {
					subTitleOne = new StringBuffer("<p class=\"question_option\">");
					String optionA = questionsVo.getOptionA();
					if (StrUtils.isNotEmpty(optionA)) {
						subTitleOne=subTitleOne.append("A.").append(optionA).append("&nbsp;&nbsp;");
					}
					String optionB = questionsVo.getOptionB();				
					if (StrUtils.isNotEmpty(optionA)) {
						subTitleOne=subTitleOne.append("B.").append(optionB).append("&nbsp;&nbsp;");
					}
					String optionC = questionsVo.getOptionC();
					if (StrUtils.isNotEmpty(optionC)) {
						subTitleOne=subTitleOne.append("C.").append(optionC).append("&nbsp;&nbsp;");
					}
					String optionD = questionsVo.getOptionD();
					if (StrUtils.isNotEmpty(optionD)) {
						subTitleOne=subTitleOne.append("D.").append(optionD).append("&nbsp;&nbsp;");
					}
					String optionE = questionsVo.getOptionE();
					if (StrUtils.isNotEmpty(optionE)) {
						subTitleOne=subTitleOne.append("E.").append(optionE).append("&nbsp;&nbsp;");
					}
					if (StrUtils.isEmpty(optionA)&&StrUtils.isNotEmpty(optionB)) {
						contentExistFlag=0;
					}
					if (StrUtils.isNotEmpty(optionC)) {
						if (StrUtils.isEmpty(optionA)||StrUtils.isEmpty(optionB)) {
							contentExistFlag=0;
						}
					}
					
					if (StrUtils.isNotEmpty(optionD)) {
						if (StrUtils.isEmpty(optionA)||StrUtils.isEmpty(optionB)||StrUtils.isEmpty(optionC)) {
							contentExistFlag=0;
						}
					}
					if (StrUtils.isNotEmpty(optionE)) {
						if (StrUtils.isEmpty(optionA)||StrUtils.isEmpty(optionB)||StrUtils.isEmpty(optionC)||StrUtils.isEmpty(optionD)) {
							contentExistFlag=0;
						}
					}
					
					subTitleOne = subTitleOne.append("</p>");
					subTitles.append(subTitleOne);
				}
			}
			if (StrUtils.isNotEmpty(subTitles)) {
				title=title+subTitles.toString();
			}
			if (testid==15788598) {
				System.out.println(15788598);
			}
			String  picExistflagTitle=null;
			if (tableFlag==0) {
				Map<String,Object> mapTitle=getNewImgsrc(title);
				Object errorTitle = mapTitle.get("error");
				if (errorTitle!=null) {
					qiniuTitleFlag="0";
				}
				picExistflagTitle = (String) mapTitle.get("picExistflag");
				title=(String) mapTitle.get("msg");
			}else if (tableFlag==1) {
			}
			
			content = HtmlTools.convertHtml(title,tableFlag);
			answer=getAnwerText(answer1,answer2);
			if (StrUtils.isNotEmpty(answer)) {
				answer=HtmlTools.convertHtml(answer,tableFlag);
			}else if (answerSub.length()>0) {
				answer=HtmlTools.convertHtml(answerSub.toString(),tableFlag);
			}
			if (StrUtils.isNotEmpty(parse)) {
				parse = HtmlTools.convertHtml(parse,tableFlag);
			}else if(parseSub.length()>0){
				parse=HtmlTools.convertHtml(parseSub.toString(),tableFlag);
			}
			Date d = new Date();
            String createTime = sdf.format(d);
            Date parseDate = null;
			try {
				parseDate = sdf.parse(createTime);
			} catch (ParseException e) {
				parseDate=new Date();
				System.out.println("error:ParseException=====");
//				e.printStackTrace();
			}
            questionXuekubao.setIdOld(id);
            questionXuekubao.setContent(content);
            questionXuekubao.setCreateTime(parseDate);
            questionXuekubao.setGrade(gradeName);
            questionXuekubao.setCourse(subjectName);
            questionXuekubao.setSolution(parse);
            questionXuekubao.setAnswer(answer);
            questionXuekubao.setPaperFlag(paperFlag);
            questionXuekubao.setContentExistFlag(contentExistFlag);
            questionXuekubao.setAnswerExistFlag(answerExistFlag);
            questionXuekubao.setParseExistFlag(parseExistFlag);
            
            if ("picExistFlag:0".equals(picExistflagParse)||"picExistFlag:0".equals(picExistflagSubParse)||"picExistFlag:0".equals(picExistflagTitle)||"picExistFlag:0".equals(picExistflagAnswer2)
            		||"picExistFlag:0".equals(picExistflagAnswer1)||"picExistFlag:0".equals(picExistFlagSubAnswer)) {
				questionXuekubao.setPicExistflag(0);
			}else if (picExistflagParse==null&&picExistflagSubParse==null&&picExistflagTitle==null&&picExistflagAnswer1==null
						&&picExistflagAnswer2==null&&picExistFlagSubAnswer==null) {
				questionXuekubao.setPicExistflag(2);
			}else{
				questionXuekubao.setPicExistflag(1);
			}
            if ((qiniuTitleFlag!=null&&"0".equals(qiniuTitleFlag))||(qiniuParseFlag!=null&&"0".equals(qiniuParseFlag))||(qiniuSubParseFlag!=null&&"0".equals(qiniuSubParseFlag))
            		||(qiniuAnswer1Flag!=null&&"0".equals(qiniuAnswer1Flag))||(qiniuAnswer2Flag!=null&&"0".equals(qiniuAnswer2Flag))||(qiniuSubAnswerFlag!=null&&"0".equals(qiniuSubAnswerFlag))) {
            	questionXuekubao.setQiniuFlag(0);
			}else{
				questionXuekubao.setQiniuFlag(1);
			}
            questionXuekubaoList.add(questionXuekubao);
		}
		int sizeList = questionXuekubaoList.size();
		//将该集合以500条数据分为N个集合，分开存储
		List<List<QuestionXuekubaoPojo>> fixedGrouping = AssignListUtils.fixedGrouping(questionXuekubaoList, 500);
		end = System.currentTimeMillis();
		if (CollectionUtils.isNotEmpty(fixedGrouping)) {
			long startEnd,endEnd;
			startEnd = System.currentTimeMillis();
			int i=0;
			System.out.println("数据处理完毕，准备入库=============================，数据处理用时："+(end-start)/1000+"s");
			Iterator<List<QuestionXuekubaoPojo>> iterator = fixedGrouping.iterator();
			Integer dataCount=0;
			while (iterator.hasNext()) {
				List<QuestionXuekubaoPojo> next = iterator.next();
				if (CollectionUtils.isNotEmpty(next)) {
					++dataCount;
					i=i+next.size();
					if (tableFlag==0) {
						if (handerWay==1) {
							questionMapper.updateQuestionXuekubaoBatch(next);
						}else{
							questionMapper.insertQuestionXuekubaoBatch(next);
						}
					}else if (tableFlag==1) {
						questionMapper.insertQuestionXuekubaoPaperBatch(next);
					}
				}
				System.out.println("----执行线程入库共"+i+"条记录----------");
			}
			endEnd = System.currentTimeMillis();
			System.out.println("数据入库完毕=============================，入库用时："+(endEnd-startEnd)/1000+"s");

		}else{
			System.out.println("没有数据需要入库，本次数据处理时间=============================，用时："+(end-start)/1000+"s");
		}
	}
	

	private static Map<String,Object> getNewImgsrc(String msg) {
		List<String> srcImgList = HtmlUtil.extralImg(msg);
		String picExistflag=null;
		Map<String,Object> map=new HashMap<String,Object>();
		if (CollectionUtils.isNotEmpty(srcImgList)) 
		{
			Iterator<String> iteratorImg = srcImgList.iterator();
			
			while (iteratorImg.hasNext()) {
				String replaceImg=null;
				String nextImg = iteratorImg.next();
				if (nextImg.contains("http")) {
					continue;
				}
				//v:shapes="image0070.jpeg"----15788598
				String[] splitNextImg = nextImg.split("/");
				if (splitNextImg.length<=2) {
					continue;
				}
				if (nextImg.contains("file:///")) {
					continue;
				}
				Boolean fileIsExist = HandlerFileNameSuffix.fileIsExist(CommonConstant.PATH_LOCAL_TIKUPIC+nextImg);
//				Boolean fileIsExist=FtpUtil.fileIsExistFTP(CommonConstant.FTP_ADDR,
//	    				21,CommonConstant.FTP_USER,
//	    				CommonConstant.FTP_PWD,CommonConstant.FTP_PATH, nextImg);
				if (fileIsExist) {
					replaceImg=getImageUrlFtp(CommonConstant.PATH_LOCAL_TIKUPIC, nextImg);
					picExistflag="picExistFlag:1";
				}else{
					picExistflag="picExistFlag:0";
				}
				if ((StrUtils.isNotEmpty(replaceImg)) && (!("qiniu:error".equals(replaceImg))))
		        {
		          msg = msg.replaceAll(nextImg, replaceImg);
		        } else if ("qiniu:error".equals(replaceImg)) {
		          map.put("error", "qiniu:error");
		        }
			}
			
		}
		map.put("msg", msg);
		map.put("picExistflag", picExistflag);
		return map;
	}
	
	
	private static String getImageUrl(String path, String name) {
		if ("/upimages/quiz/images/201507/221/076e7015.png".equals(name)) {
			System.out.println("Error:"+name);
		}
		String url = null;
        try
        {
            url = QiniuUtil.uploadFile(name, path + name, "common-pic", false);
            Thread.sleep(100);
        }
        catch (Exception e)
        {
//            throw new BizException(FailedStatusEnum.QINIU_UPLOAD_ERROR, "name:" + name);
        	System.out.println("qiniu:error====="+e.toString());
        	return "qiniu:error";
        }
        return url;
	}
	private static Boolean fileIsExist(String file) {
		File fileName = new File(file);
		if (fileName.isDirectory()) {
			return false;
		}
		if (fileName.exists()) {
			return true;
		}else{
			return false;
		}
	}
	
	private static String getImageUrlFtp(String path, String name) {
		String url = null;
		StringBuffer bfImg=new StringBuffer("");
        try
        {
        	InputStream in = HandlerFileNameSuffix.getLocalFileSteam(CommonConstant.PATH_LOCAL_TIKUPIC, name);
//        	InputStream in = FtpUtil.getFileSteam(CommonConstant.FTP_ADDR,
//        			21,CommonConstant.FTP_USER,
//        			CommonConstant.FTP_PWD,CommonConstant.FTP_PATH, name
//        			);
        	name = HandlerFileNameSuffix.getCorrectFileName(name);
            url = QiniuUtil.uploadFile(name, in, "common-pic", false);
            Thread.sleep(100);
        }
        catch (Exception e)
        {
        	System.out.println("qiniu:error====="+e.toString());
        	return "qiniu:error";
        }
        return url;
	}
	public static String getAnwerText(String answer1,String answer2){
			String answer=null;
		if (StrUtils.isNotEmpty(answer1)&&StrUtils.isNotEmpty(answer2)) {
			Pattern panswer2 = Pattern.compile("^【(.*)$");
	        Matcher manswer2 = panswer2.matcher(answer2);
			if (manswer2.find()) {
				answer = answer1+"<br />"+answer2;
			}else{
				Pattern p = Pattern.compile("^m\\{(.*)}$");
		        Matcher m = p.matcher(answer1);
		        String regexAnswer1="";
		        if (m.find()) {
					System.out.println("匹配上了");
					String[] split = answer1.split("m\\{");
					for (int i = 1; i < split.length; i++) {
						regexAnswer1=regexAnswer1+split[i].charAt(0);
						answer1=regexAnswer1;
					}
				}
				answer=answer1;
			}
		}else if (StrUtils.isNotEmpty(answer1)) {
			answer = answer1;
		}else if(StrUtils.isNotEmpty(answer2)){
			answer = answer2;
		}
		return answer;
	}
}
